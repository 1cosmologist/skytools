<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skytools.hpx_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skytools.hpx_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#######################################################################
# This file is a part of SkyTools
#
# Sky Tools
# Copyright (C) 2023  Shamik Ghosh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
#
# For more information about SkyTools please visit 
# &lt;https://github.com/1cosmologist/skytools&gt; or contact Shamik Ghosh 
# at shamik@lbl.gov
#
#########################################################################

import numpy as np
import healpy as hp
import os 

datapath = os.getenv(&#39;SKYTOOLS_DATA&#39;)

__pdoc__ = {}
# __pdoc__[&#39;&#39;] = False

def apodized_gauss_beam(fwhm, lmax):
    Bl = hp.gauss_beam(np.deg2rad(fwhm / 60.), lmax=lmax)

    Bl_apo = np.copy(Bl)
    dBl = np.gradient(Bl) 

    ells = np.arange(lmax+1, dtype=np.int16)

    ell_intercept = ells - Bl / dBl
    # lmax_intercept = Bl + (lmax - ells) * dBl

    if np.sum(ell_intercept &lt;= lmax) &gt; 0:
        ell_0 = np.where(ell_intercept &lt;= lmax)[0][-1]
    else:
        print(&#39;Warning: lmax is too small for a beam that size&#39;)
        # dummy = np.min(lmax_intercept, ell_0)

    tangent = Bl[ell_0] + (ells - ell_0) * dBl[ell_0]
    Bl_apo[ell_0:] = tangent[ell_0:]
    
    return Bl_apo

def compute_beam_ratio(beam_nu, beam_0, thresh=0.):
    &#34;&#34;&#34;
    Computes beam ratio to change the resolution/beam smoothing of a single map/alm.

    Parameters
    ----------
    beam_nu : numpy array
        A numpy 1D array of shape [lmax+1], containing the original/native beam of the data. 
        If polarized beam contains either the E component or the B component depending on 
        which map/alm is being targeted. This represents $$B^{T/E/B}_{\\ell}$$ for the 
        different maps in the set.
    beam_0 : numpy array
        A numpy 1D array of shape [lmax+1] representing the beam of the common resolution 
        that is being targetted.

    Returns
    -------
    numpy array
        A numpy 1D array of shape [lmax+1] that contains multiplicative factors 
        to convert map alms to the common resolution. 
    &#34;&#34;&#34;

    lmax_beam = len(beam_nu)

    ratio_nu = np.zeros((lmax_beam))

    lmax_nonzero = np.max(np.where(beam_nu&gt;thresh))+1
    ratio_nu[0:lmax_nonzero] = beam_0[0:lmax_nonzero] / beam_nu[0:lmax_nonzero]

    del lmax_beam, lmax_nonzero, beam_nu, beam_0
    return ratio_nu


def iqu2teb(map_iqu, mask_in=None, nside=None, teb=&#39;te&#39;, lmax_sht=None, return_alm=False):
    
    if nside == None:
        nside = hp.get_nside(map_iqu[0])

    if not isinstance(mask_in,(list, np.ndarray)):
        mask_in = np.ones_like((hp.nside2npix(nside),))

    mask_arr = [mask_in, mask_in, mask_in]
    alms = hp.map2alm(map_iqu * mask_arr, lmax=lmax_sht, use_weights=True, datapath=datapath)

    mask_bin = np.ones_like(mask_in)
    mask_bin[mask_in == 0.] = 0.

    teb_maps = []
    if (&#39;t&#39; in teb) or (&#39;T&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[0])
        else:
            teb_maps.append(hp.alm2map(alms[0], nside, lmax=lmax_sht, pol=False) * mask_bin)
    if (&#39;e&#39; in teb) or (&#39;E&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[1])
        else:
            teb_maps.append(hp.alm2map(alms[1], nside, lmax=lmax_sht, pol=False) * mask_bin)
    if (&#39;b&#39; in teb) or (&#39;B&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[2])
        else:
            teb_maps.append(hp.alm2map(alms[2], nside, lmax=lmax_sht, pol=False) * mask_bin)

    return np.array(teb_maps)



def calc_binned_Cl(alm1, alm2=None):
    ALM = hp.Alm()
    lmax = ALM.getlmax(len(alm1))

    Cl_1x2 = hp.alm2cl(alm1, alms2=alm2)

    # ells = np.arange(lmax+1)
    # mode_factor = 2.*ells + 1. 
    # Cl_1x2 = mode_factor * Cl_1x2

    Cl_binned = np.zeros((lmax+1,))

    for li in range(2, len(Cl_1x2)) :
            limin = np.maximum(int(np.floor(np.minimum(0.8*li, li-5))), 2)
            limax = np.minimum(int(np.ceil(np.maximum(1.2*li, li+5))), lmax-1)
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)
            Cl_binned[li] = (np.sum(Cl_1x2[limin:limax])) / (limax - limin) #) 

    del Cl_1x2 

    Cl_binned = np.reshape(Cl_binned,(1,len(Cl_binned)))
    return Cl_binned


def roll_bin_Cl(Cl_in, dl_min=10, dlbyl=0.4, dl_max=None, fmt_nmt=False):
    Cl_in = np.array(Cl_in)

    if Cl_in.ndim &gt; 2:
        raise Exception(&#34;ERROR: Upto 2-d Cl arrays supported in form [ndim, lmax+1]&#34;)
        
    elif Cl_in.ndim == 2:
        # Assume that Cl_in is [nmaps, lmax+1] in size
        lmax = len(Cl_in[0]) - 1
        nmaps = len(Cl_in)
        Cl_1x2 = np.copy(Cl_in)

        Cl_binned = np.zeros((nmaps, lmax+1))

        for li in range(2, lmax+1) :
            limin = np.maximum((np.floor(np.minimum((1-dlbyl/2)*li, li-(dl_min/2)))), 2)
            limax = np.minimum((np.ceil(np.maximum((1+dlbyl/2)*li, li+(dl_min/2)))), lmax-1)

            if dl_max != None:
                limin = np.maximum(limin, int(np.floor(li - (dl_max/2))))
                limax = np.minimum(limax, int(np.ceil(li + (dl_max/2))))
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)

            Cl_binned[:,li] = (np.sum(np.copy(Cl_1x2)[:,limin:limax], axis=1)) / (limax - limin) #)

        del Cl_1x2

        if fmt_nmt:
            Cl_binned = np.reshape(Cl_binned,(nmaps, 1, lmax+1))
    else:
        lmax = len(Cl_in) - 1

        Cl_1x2 = np.copy(np.array(Cl_in))

        # ells = np.arange(lmax+1)
        # mode_factor = 2.*ells + 1. 
        # Cl_1x2 = mode_factor * Cl_1x2

        Cl_binned = np.zeros((lmax+1,))

        for li in range(2, len(Cl_1x2)) :
            limin = np.maximum(int(np.floor(np.minimum((1-dlbyl/2)*li, li-(dl_min/2)))), 2)
            limax = np.minimum(int(np.ceil(np.maximum((1+dlbyl/2)*li, li+(dl_min/2)))), lmax-1)

            if dl_max != None:
                limin = np.maximum(limin, int(np.floor(li - (dl_max/2))))
                limax = np.minimum(limax, int(np.ceil(li + (dl_max/2))))
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)
            Cl_binned[li] = (np.sum(Cl_1x2[limin:limax])) / (limax - limin) #) 

        del Cl_1x2 

        if fmt_nmt:
            Cl_binned = np.reshape(Cl_binned,(1,len(Cl_binned)))

    return Cl_binned

def process_alm(alm_in, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None, mode=&#39;i&#39;):
    alm_in = np.array(alm_in)

    if alm_in.ndim &lt; 2:
        n_alms = 1
        alm_in = np.reshape(alm_in, (1, len(alm_in)))
    elif alm_in.ndim == 2:
        n_alms = alm_in.shape[0]
    else:
        raise Exception(&#34;ERROR: The shape alm array is unrecognized. Aborting!&#34;)

    if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (n_alms != 3):
        raise Exception(&#34;ERROR: For IQU/TEB mode 3 alms are to be supplied. Aborting!&#34;)


    ALM = hp.Alm()
    lmax = ALM.getlmax(len(alm_in[0]))

    if isinstance(beam_in, (np.ndarray, list, tuple)):
        beam_in = np.array(beam_in)

        if beam_in.ndim == 1:
            nbeams_in = 1.
        else: 
            nbeams_in = beam_in.shape[1]
            if nbeams_in != n_alms:
                raise Exception(&#34;ERROR: Either supply same number of beams as alms or supply one to use for all. Aborting!&#34;)
                
        if len(beam_in) != lmax+1:
                raise Exception(&#34;ERROR: beam_in must have same lmax as alm. Aborting!&#34;)
                
        if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nbeams_in != 3):
            raise Exception(&#34;ERROR: For IQU/TEB mode 3 input beams are to be supplied. Aborting!&#34;)
    else:
        if fwhm_in != None:
            beam_in = hp.gauss_beam(np.deg2rad(fwhm_in / 60.), lmax=lmax, pol=True)[:,:3]
            nbeams_in = 3

            if mode.lower() in [&#39;i&#39;, &#39;t&#39;]:
                beam_in = beam_in[:,0]
                nbeams_in = 1
            elif mode.lower() in [&#39;e&#39;, &#39;b&#39;, &#39;eb&#39;]:
                beam_in = beam_in[:,1]
                nbeams_in = 1
            elif not (mode.lower() in [&#39;iqu&#39;,&#39;teb&#39;]):
                raise Exception(&#34;ERROR: Unrecognized mode! Only supported options={t, e, b, eb, i, qu, teb, iqu}. Aborting!&#34;)
        else:
            beam_in = np.ones((lmax+1,))
            nbeams_in = 1

            
    if isinstance(beam_out, (np.ndarray, list, tuple)):
        beam_out = np.array(beam_out)
        if beam_out.ndim == 1:
            nbeams_out = 1.
        else: 
            nbeams_out = beam_out.shape[1]
            if nbeams_out != n_alms:
                raise Exception(&#34;ERROR: Either supply same number of beams as alms or supply one to use for all. Aborting!&#34;)

        if len(beam_out) != lmax+1:
                raise Exception(&#34;ERROR: beam_out must have same lmax as alm. Aborting!&#34;)

        if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nbeams_out != 3):
            raise Exception(&#34;ERROR: For IQU/TEB mode 3 output beams are to be supplied. Aborting!&#34;)
    else:
        if fwhm_out != None:
            beam_out = hp.gauss_beam(np.deg2rad(fwhm_out / 60.), lmax=lmax, pol=True)[:,:3]
            nbeams_out = 3

            if mode.lower() in [&#39;i&#39;, &#39;t&#39;]:
                beam_out = beam_out[:,0]
                nbeams_out = 1
            elif mode.lower() in [&#39;e&#39;, &#39;b&#39;, &#39;eb&#39;,]:
                beam_out = beam_out[:,1]
                nbeams_out = 1
            elif not (mode.lower() in [&#39;iqu&#39;,&#39;teb&#39;]):
                raise Exception(&#34;ERROR: Unrecognized mode! Only supported options={t, e, b, eb, i, teb, iqu}. Aborting!&#34;)
        else:
            beam_out = np.ones((lmax+1,))
            nbeams_out = 1

    # print(n_alms, beam_in.shape, beam_out.shape, alm_in.shape)
    if isinstance(pixwin_in, (int,float)):
        pixwin_in = hp.pixwin(int(pixwin_in), lmax=lmax)
        beam_in *= pixwin_in
    
    if isinstance(pixwin_out, (int,float)):
        pixwin_out = hp.pixwin(int(pixwin_out), lmax=lmax)
        beam_out *= pixwin_out

    if (nbeams_in == 1) and (nbeams_out == 1):
        beam_factor = compute_beam_ratio(beam_in, beam_out)
        alm_out = np.zeros_like(alm_in)

        for i in range(n_alms):
            alm_out[i] = hp.almxfl(alm_in[i], beam_factor)

        del alm_in, beam_factor, beam_in, beam_out

        if n_alms == 1: return alm_out[0]

        return alm_out
    
    if n_alms &gt; 1 and nbeams_in*nbeams_out &gt; 1:
        beam_factor = np.zeros((lmax+1, max(nbeams_in, nbeams_out)))
        if nbeams_in == nbeams_out:
            for ibeam in range(nbeams_in):
                beam_factor[:,ibeam] = compute_beam_ratio(beam_in[:,ibeam], beam_out[:,ibeam])
        elif (nbeams_in &gt; nbeams_out) and (nbeams_out == 1):
            for ibeam in range(nbeams_in):
                beam_factor[:,ibeam] = compute_beam_ratio(beam_in[:,ibeam], beam_out)
        
        # print(beam_factor.shape, beam_factor)
        alm_out = np.zeros_like(alm_in)
        for i in range(n_alms):
            alm_out[i] = hp.almxfl(alm_in[i], beam_factor[:,i])

        return alm_out
    
    else:
        raise Exception(&#34;ERROR: Wrong number of beams given. Ensure nbeams_in &gt;= nbeams_out and n_alms &gt;= max(nbeams_in, nbeams_out). Aborting!&#34;)
    
    
def change_resolution(map_in, nside_out=None, mode=&#39;i&#39;, lmax_sht=None, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None):
    map_to_grd = np.array(map_in)

    if map_to_grd.ndim == 1 :
        nside_in = hp.get_nside(map_to_grd)
        nmaps = 1
    else:
        nside_in = hp.get_nside(map_to_grd[0])
        nmaps = len(map_to_grd[:,0])

    if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nmaps != 3):
        raise Exception(&#34;ERROR: NMAPS != 3 is wrong for mode TEB/IQU mode.&#34;)

    if nside_out == None:
        nside_out = nside_in 

    if lmax_sht == None:
        lmax = 3 * min(nside_in, nside_out) - 1
    else:
        lmax = min(3 * min(nside_in, nside_out) - 1, lmax_sht)

    if (mode.lower() == &#39;iqu&#39;) or (nmaps == 1):
        alms = hp.map2alm(map_to_grd, lmax=lmax, use_weights=True, datapath=datapath)
    if (mode.lower() in [&#39;i&#39;, &#39;t&#39;, &#39;e&#39;, &#39;b&#39;, &#39;eb&#39;, &#39;teb&#39;]) and (nmaps &gt; 1):
        alms = []
        for i in range(nmaps):
            alms.append(hp.map2alm(map_to_grd[i], lmax=lmax, use_weights=True, datapath=datapath))
    alms = np.array(alms)

    alms_out = process_alm(alms, mode=mode, fwhm_in=fwhm_in, fwhm_out=fwhm_out, beam_in=beam_in, beam_out=beam_out, pixwin_in=pixwin_in, pixwin_out=pixwin_out)
    
    del alms 

    if nmaps == 1:
        maps_out = hp.alm2map(alms_out, nside_out, lmax=lmax, pol=False)
    elif (mode.lower() == &#39;iqu&#39;):
        maps_out = hp.alm2map(alms_out, nside_out, lmax=lmax, pol=True)
    elif (mode.lower() in [&#39;i&#39;, &#39;t&#39;, &#39;e&#39;, &#39;b&#39;, &#39;eb&#39;, &#39;teb&#39;]) and (nmaps &gt; 1):
        maps_out = []
        for i in range(nmaps):
            maps_out.append(hp.alm2map(alms_out[i], nside_out, lmax=lmax, pol=True))
    maps_out = np.array(maps_out)

    return maps_out

def mask_udgrade(mask_in, nside_out, cut_val=0.9):
    nside_in = hp.get_nside(mask_in)
    if nside_out != nside_in:
        mask_out = hp.ud_grade(mask_in, nside_out)
    else:
        mask_out = np.copy(mask_in)
        
    mask_out[mask_out &gt; cut_val] = 1.
    mask_out[mask_out &lt;= cut_val] = 0.

    return mask_out


def alm_fort2c(alm_in):
    # Assume alm shape to be [lmax, mmax] for nmaps = 1 and [nmaps, lmax, mmax] &gt;= 1

    alm_fort = np.array(alm_in)

    alm_dim = alm_fort.ndim

    if alm_dim == 3:
        nmaps = len(alm_fort[:,0,0])
        lmax = len(alm_fort[0,:,0]) - 1
        mmax = len(alm_fort[0,0,:]) - 1
    elif alm_dim == 2:
        lmax = len(alm_fort[:,0]) - 1
        mmax = len(alm_fort[0,:]) - 1
    else:
        raise Exception(&#34;ERROR: Fortran-type alm has wrong dimensions. Only [nmaps, lmax, mmax] or [lmax, mmax] supported&#34;)

    ALM = hp.Alm()
    c_alm_size = ALM.getsize(lmax,mmax)
    ls, ms = ALM.getlm(lmax)

    idx_arr = np.arange(c_alm_size)

    if alm_dim == 3:
        alm_c = np.zeros((nmaps, c_alm_size), dtype=np.complex128)
        alm_c[:,idx_arr] = alm_fort[:, ls, ms]
    else:
        alm_c = np.zeros((c_alm_size,), dtype=np.complex128)
        alm_c[idx_arr] = alm_fort[ls, ms]

    return alm_c
    

def alm_c2fort(alm_in):
    # Assume alm shape to be [midx,] for nmaps = 1 and [nmaps, midx] &gt;= 1

    alm_c = np.array(alm_in)

    alm_dim = alm_c.ndim

    if alm_dim == 2:
        nmaps = len(alm_c[:,0]) 
        midx = len(alm_c[0,:])
    elif alm_dim == 1:
        midx = len(alm_c[:])
    else:
        raise Exception(&#34;ERROR: C-type alm has wrong dimensions. Only [nmaps, midx] or [midx] supported&#34;)
    
    ALM = hp.Alm()
    lmax = ALM.getlmax(midx)
    mmax = lmax 

    idx_arr = np.arange(midx)

    ls, ms = ALM.getlm(lmax, i=idx_arr)

    if alm_dim == 2:
        alm_fort = np.zeros((nmaps, lmax+1, mmax+1), dtype=np.complex128)
        alm_fort[:,ls, ms] = alm_c[:,idx_arr]
    else:
        alm_fort = np.zeros((lmax+1, mmax+1), dtype=np.complex128)
        alm_fort[ls, ms] = alm_c[idx_arr]

    return alm_fort 

def query_dist(nside, vec_center, radius_in_rad, inclusive=True):
    disc_pix = np.array(hp.query_disc(nside, vec_center, radius_in_rad, inclusive=inclusive))

    vec_center = np.reshape(vec_center, (3,1))
    vec_disc = np.array(hp.pix2vec(nside, disc_pix))
    
    pix_dist = np.arccos(vec_disc.T @ vec_center)[:,0]

    return disc_pix, pix_dist


def angdist(nside1, pixlist1, nside2, pixlist2):
    vec_mat1 = np.array(hp.pix2vec(nside1, pixlist1), dtype=np.float32)       
    vec_mat2 = np.array(hp.pix2vec(nside2, pixlist2), dtype=np.float32)

    # print(vec_mat1.T.shape, vec_mat2.shape)

    return np.arccos(vec_mat1.T @ vec_mat2).astype(np.float32)

    
def alm_c_lmaxchanger(lmax_i, lmax_f):
    ALM = hp.Alm()
    if lmax_i &lt; lmax_f:
        cidx_max = ALM.getsize(lmax_i)
        ls, ms = ALM.getlm(lmax_i, np.arange(cidx_max, dtype=np.int64))
        return ALM.getidx(lmax_f, ls, ms)
    elif lmax_i &gt; lmax_f:
        cidx_max = ALM.getsize(lmax_i)
        ls, ms = ALM.getlm(lmax_i, np.arange(cidx_max, dtype=np.int64))

        ms = ms[ls &lt;= lmax_f]
        ls = ls[ls &lt;= lmax_f]
        return ALM.getidx(lmax_i, ls, ms)
    else:
        return np.arange(ALM.getsize(lmax_i), dtype=np.int64)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="skytools.hpx_utils.alm_c2fort"><code class="name flex">
<span>def <span class="ident">alm_c2fort</span></span>(<span>alm_in)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alm_c2fort(alm_in):
    # Assume alm shape to be [midx,] for nmaps = 1 and [nmaps, midx] &gt;= 1

    alm_c = np.array(alm_in)

    alm_dim = alm_c.ndim

    if alm_dim == 2:
        nmaps = len(alm_c[:,0]) 
        midx = len(alm_c[0,:])
    elif alm_dim == 1:
        midx = len(alm_c[:])
    else:
        raise Exception(&#34;ERROR: C-type alm has wrong dimensions. Only [nmaps, midx] or [midx] supported&#34;)
    
    ALM = hp.Alm()
    lmax = ALM.getlmax(midx)
    mmax = lmax 

    idx_arr = np.arange(midx)

    ls, ms = ALM.getlm(lmax, i=idx_arr)

    if alm_dim == 2:
        alm_fort = np.zeros((nmaps, lmax+1, mmax+1), dtype=np.complex128)
        alm_fort[:,ls, ms] = alm_c[:,idx_arr]
    else:
        alm_fort = np.zeros((lmax+1, mmax+1), dtype=np.complex128)
        alm_fort[ls, ms] = alm_c[idx_arr]

    return alm_fort </code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.alm_c_lmaxchanger"><code class="name flex">
<span>def <span class="ident">alm_c_lmaxchanger</span></span>(<span>lmax_i, lmax_f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alm_c_lmaxchanger(lmax_i, lmax_f):
    ALM = hp.Alm()
    if lmax_i &lt; lmax_f:
        cidx_max = ALM.getsize(lmax_i)
        ls, ms = ALM.getlm(lmax_i, np.arange(cidx_max, dtype=np.int64))
        return ALM.getidx(lmax_f, ls, ms)
    elif lmax_i &gt; lmax_f:
        cidx_max = ALM.getsize(lmax_i)
        ls, ms = ALM.getlm(lmax_i, np.arange(cidx_max, dtype=np.int64))

        ms = ms[ls &lt;= lmax_f]
        ls = ls[ls &lt;= lmax_f]
        return ALM.getidx(lmax_i, ls, ms)
    else:
        return np.arange(ALM.getsize(lmax_i), dtype=np.int64)</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.alm_fort2c"><code class="name flex">
<span>def <span class="ident">alm_fort2c</span></span>(<span>alm_in)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alm_fort2c(alm_in):
    # Assume alm shape to be [lmax, mmax] for nmaps = 1 and [nmaps, lmax, mmax] &gt;= 1

    alm_fort = np.array(alm_in)

    alm_dim = alm_fort.ndim

    if alm_dim == 3:
        nmaps = len(alm_fort[:,0,0])
        lmax = len(alm_fort[0,:,0]) - 1
        mmax = len(alm_fort[0,0,:]) - 1
    elif alm_dim == 2:
        lmax = len(alm_fort[:,0]) - 1
        mmax = len(alm_fort[0,:]) - 1
    else:
        raise Exception(&#34;ERROR: Fortran-type alm has wrong dimensions. Only [nmaps, lmax, mmax] or [lmax, mmax] supported&#34;)

    ALM = hp.Alm()
    c_alm_size = ALM.getsize(lmax,mmax)
    ls, ms = ALM.getlm(lmax)

    idx_arr = np.arange(c_alm_size)

    if alm_dim == 3:
        alm_c = np.zeros((nmaps, c_alm_size), dtype=np.complex128)
        alm_c[:,idx_arr] = alm_fort[:, ls, ms]
    else:
        alm_c = np.zeros((c_alm_size,), dtype=np.complex128)
        alm_c[idx_arr] = alm_fort[ls, ms]

    return alm_c</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.angdist"><code class="name flex">
<span>def <span class="ident">angdist</span></span>(<span>nside1, pixlist1, nside2, pixlist2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angdist(nside1, pixlist1, nside2, pixlist2):
    vec_mat1 = np.array(hp.pix2vec(nside1, pixlist1), dtype=np.float32)       
    vec_mat2 = np.array(hp.pix2vec(nside2, pixlist2), dtype=np.float32)

    # print(vec_mat1.T.shape, vec_mat2.shape)

    return np.arccos(vec_mat1.T @ vec_mat2).astype(np.float32)</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.apodized_gauss_beam"><code class="name flex">
<span>def <span class="ident">apodized_gauss_beam</span></span>(<span>fwhm, lmax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apodized_gauss_beam(fwhm, lmax):
    Bl = hp.gauss_beam(np.deg2rad(fwhm / 60.), lmax=lmax)

    Bl_apo = np.copy(Bl)
    dBl = np.gradient(Bl) 

    ells = np.arange(lmax+1, dtype=np.int16)

    ell_intercept = ells - Bl / dBl
    # lmax_intercept = Bl + (lmax - ells) * dBl

    if np.sum(ell_intercept &lt;= lmax) &gt; 0:
        ell_0 = np.where(ell_intercept &lt;= lmax)[0][-1]
    else:
        print(&#39;Warning: lmax is too small for a beam that size&#39;)
        # dummy = np.min(lmax_intercept, ell_0)

    tangent = Bl[ell_0] + (ells - ell_0) * dBl[ell_0]
    Bl_apo[ell_0:] = tangent[ell_0:]
    
    return Bl_apo</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.calc_binned_Cl"><code class="name flex">
<span>def <span class="ident">calc_binned_Cl</span></span>(<span>alm1, alm2=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_binned_Cl(alm1, alm2=None):
    ALM = hp.Alm()
    lmax = ALM.getlmax(len(alm1))

    Cl_1x2 = hp.alm2cl(alm1, alms2=alm2)

    # ells = np.arange(lmax+1)
    # mode_factor = 2.*ells + 1. 
    # Cl_1x2 = mode_factor * Cl_1x2

    Cl_binned = np.zeros((lmax+1,))

    for li in range(2, len(Cl_1x2)) :
            limin = np.maximum(int(np.floor(np.minimum(0.8*li, li-5))), 2)
            limax = np.minimum(int(np.ceil(np.maximum(1.2*li, li+5))), lmax-1)
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)
            Cl_binned[li] = (np.sum(Cl_1x2[limin:limax])) / (limax - limin) #) 

    del Cl_1x2 

    Cl_binned = np.reshape(Cl_binned,(1,len(Cl_binned)))
    return Cl_binned</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.change_resolution"><code class="name flex">
<span>def <span class="ident">change_resolution</span></span>(<span>map_in, nside_out=None, mode='i', lmax_sht=None, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_resolution(map_in, nside_out=None, mode=&#39;i&#39;, lmax_sht=None, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None):
    map_to_grd = np.array(map_in)

    if map_to_grd.ndim == 1 :
        nside_in = hp.get_nside(map_to_grd)
        nmaps = 1
    else:
        nside_in = hp.get_nside(map_to_grd[0])
        nmaps = len(map_to_grd[:,0])

    if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nmaps != 3):
        raise Exception(&#34;ERROR: NMAPS != 3 is wrong for mode TEB/IQU mode.&#34;)

    if nside_out == None:
        nside_out = nside_in 

    if lmax_sht == None:
        lmax = 3 * min(nside_in, nside_out) - 1
    else:
        lmax = min(3 * min(nside_in, nside_out) - 1, lmax_sht)

    if (mode.lower() == &#39;iqu&#39;) or (nmaps == 1):
        alms = hp.map2alm(map_to_grd, lmax=lmax, use_weights=True, datapath=datapath)
    if (mode.lower() in [&#39;i&#39;, &#39;t&#39;, &#39;e&#39;, &#39;b&#39;, &#39;eb&#39;, &#39;teb&#39;]) and (nmaps &gt; 1):
        alms = []
        for i in range(nmaps):
            alms.append(hp.map2alm(map_to_grd[i], lmax=lmax, use_weights=True, datapath=datapath))
    alms = np.array(alms)

    alms_out = process_alm(alms, mode=mode, fwhm_in=fwhm_in, fwhm_out=fwhm_out, beam_in=beam_in, beam_out=beam_out, pixwin_in=pixwin_in, pixwin_out=pixwin_out)
    
    del alms 

    if nmaps == 1:
        maps_out = hp.alm2map(alms_out, nside_out, lmax=lmax, pol=False)
    elif (mode.lower() == &#39;iqu&#39;):
        maps_out = hp.alm2map(alms_out, nside_out, lmax=lmax, pol=True)
    elif (mode.lower() in [&#39;i&#39;, &#39;t&#39;, &#39;e&#39;, &#39;b&#39;, &#39;eb&#39;, &#39;teb&#39;]) and (nmaps &gt; 1):
        maps_out = []
        for i in range(nmaps):
            maps_out.append(hp.alm2map(alms_out[i], nside_out, lmax=lmax, pol=True))
    maps_out = np.array(maps_out)

    return maps_out</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.compute_beam_ratio"><code class="name flex">
<span>def <span class="ident">compute_beam_ratio</span></span>(<span>beam_nu, beam_0, thresh=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes beam ratio to change the resolution/beam smoothing of a single map/alm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beam_nu</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>A numpy 1D array of shape [lmax+1], containing the original/native beam of the data.
If polarized beam contains either the E component or the B component depending on
which map/alm is being targeted. This represents $$B^{T/E/B}_{\ell}$$ for the
different maps in the set.</dd>
<dt><strong><code>beam_0</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>A numpy 1D array of shape [lmax+1] representing the beam of the common resolution
that is being targetted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>A numpy 1D array of shape [lmax+1] that contains multiplicative factors
to convert map alms to the common resolution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_beam_ratio(beam_nu, beam_0, thresh=0.):
    &#34;&#34;&#34;
    Computes beam ratio to change the resolution/beam smoothing of a single map/alm.

    Parameters
    ----------
    beam_nu : numpy array
        A numpy 1D array of shape [lmax+1], containing the original/native beam of the data. 
        If polarized beam contains either the E component or the B component depending on 
        which map/alm is being targeted. This represents $$B^{T/E/B}_{\\ell}$$ for the 
        different maps in the set.
    beam_0 : numpy array
        A numpy 1D array of shape [lmax+1] representing the beam of the common resolution 
        that is being targetted.

    Returns
    -------
    numpy array
        A numpy 1D array of shape [lmax+1] that contains multiplicative factors 
        to convert map alms to the common resolution. 
    &#34;&#34;&#34;

    lmax_beam = len(beam_nu)

    ratio_nu = np.zeros((lmax_beam))

    lmax_nonzero = np.max(np.where(beam_nu&gt;thresh))+1
    ratio_nu[0:lmax_nonzero] = beam_0[0:lmax_nonzero] / beam_nu[0:lmax_nonzero]

    del lmax_beam, lmax_nonzero, beam_nu, beam_0
    return ratio_nu</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.iqu2teb"><code class="name flex">
<span>def <span class="ident">iqu2teb</span></span>(<span>map_iqu, mask_in=None, nside=None, teb='te', lmax_sht=None, return_alm=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iqu2teb(map_iqu, mask_in=None, nside=None, teb=&#39;te&#39;, lmax_sht=None, return_alm=False):
    
    if nside == None:
        nside = hp.get_nside(map_iqu[0])

    if not isinstance(mask_in,(list, np.ndarray)):
        mask_in = np.ones_like((hp.nside2npix(nside),))

    mask_arr = [mask_in, mask_in, mask_in]
    alms = hp.map2alm(map_iqu * mask_arr, lmax=lmax_sht, use_weights=True, datapath=datapath)

    mask_bin = np.ones_like(mask_in)
    mask_bin[mask_in == 0.] = 0.

    teb_maps = []
    if (&#39;t&#39; in teb) or (&#39;T&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[0])
        else:
            teb_maps.append(hp.alm2map(alms[0], nside, lmax=lmax_sht, pol=False) * mask_bin)
    if (&#39;e&#39; in teb) or (&#39;E&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[1])
        else:
            teb_maps.append(hp.alm2map(alms[1], nside, lmax=lmax_sht, pol=False) * mask_bin)
    if (&#39;b&#39; in teb) or (&#39;B&#39; in teb) :
        if return_alm:
            teb_maps.append(alms[2])
        else:
            teb_maps.append(hp.alm2map(alms[2], nside, lmax=lmax_sht, pol=False) * mask_bin)

    return np.array(teb_maps)</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.mask_udgrade"><code class="name flex">
<span>def <span class="ident">mask_udgrade</span></span>(<span>mask_in, nside_out, cut_val=0.9)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_udgrade(mask_in, nside_out, cut_val=0.9):
    nside_in = hp.get_nside(mask_in)
    if nside_out != nside_in:
        mask_out = hp.ud_grade(mask_in, nside_out)
    else:
        mask_out = np.copy(mask_in)
        
    mask_out[mask_out &gt; cut_val] = 1.
    mask_out[mask_out &lt;= cut_val] = 0.

    return mask_out</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.process_alm"><code class="name flex">
<span>def <span class="ident">process_alm</span></span>(<span>alm_in, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None, mode='i')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_alm(alm_in, fwhm_in=None, fwhm_out=None, beam_in=None, beam_out=None, pixwin_in=None, pixwin_out=None, mode=&#39;i&#39;):
    alm_in = np.array(alm_in)

    if alm_in.ndim &lt; 2:
        n_alms = 1
        alm_in = np.reshape(alm_in, (1, len(alm_in)))
    elif alm_in.ndim == 2:
        n_alms = alm_in.shape[0]
    else:
        raise Exception(&#34;ERROR: The shape alm array is unrecognized. Aborting!&#34;)

    if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (n_alms != 3):
        raise Exception(&#34;ERROR: For IQU/TEB mode 3 alms are to be supplied. Aborting!&#34;)


    ALM = hp.Alm()
    lmax = ALM.getlmax(len(alm_in[0]))

    if isinstance(beam_in, (np.ndarray, list, tuple)):
        beam_in = np.array(beam_in)

        if beam_in.ndim == 1:
            nbeams_in = 1.
        else: 
            nbeams_in = beam_in.shape[1]
            if nbeams_in != n_alms:
                raise Exception(&#34;ERROR: Either supply same number of beams as alms or supply one to use for all. Aborting!&#34;)
                
        if len(beam_in) != lmax+1:
                raise Exception(&#34;ERROR: beam_in must have same lmax as alm. Aborting!&#34;)
                
        if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nbeams_in != 3):
            raise Exception(&#34;ERROR: For IQU/TEB mode 3 input beams are to be supplied. Aborting!&#34;)
    else:
        if fwhm_in != None:
            beam_in = hp.gauss_beam(np.deg2rad(fwhm_in / 60.), lmax=lmax, pol=True)[:,:3]
            nbeams_in = 3

            if mode.lower() in [&#39;i&#39;, &#39;t&#39;]:
                beam_in = beam_in[:,0]
                nbeams_in = 1
            elif mode.lower() in [&#39;e&#39;, &#39;b&#39;, &#39;eb&#39;]:
                beam_in = beam_in[:,1]
                nbeams_in = 1
            elif not (mode.lower() in [&#39;iqu&#39;,&#39;teb&#39;]):
                raise Exception(&#34;ERROR: Unrecognized mode! Only supported options={t, e, b, eb, i, qu, teb, iqu}. Aborting!&#34;)
        else:
            beam_in = np.ones((lmax+1,))
            nbeams_in = 1

            
    if isinstance(beam_out, (np.ndarray, list, tuple)):
        beam_out = np.array(beam_out)
        if beam_out.ndim == 1:
            nbeams_out = 1.
        else: 
            nbeams_out = beam_out.shape[1]
            if nbeams_out != n_alms:
                raise Exception(&#34;ERROR: Either supply same number of beams as alms or supply one to use for all. Aborting!&#34;)

        if len(beam_out) != lmax+1:
                raise Exception(&#34;ERROR: beam_out must have same lmax as alm. Aborting!&#34;)

        if (mode.lower() in [&#39;iqu&#39;, &#39;teb&#39;]) and (nbeams_out != 3):
            raise Exception(&#34;ERROR: For IQU/TEB mode 3 output beams are to be supplied. Aborting!&#34;)
    else:
        if fwhm_out != None:
            beam_out = hp.gauss_beam(np.deg2rad(fwhm_out / 60.), lmax=lmax, pol=True)[:,:3]
            nbeams_out = 3

            if mode.lower() in [&#39;i&#39;, &#39;t&#39;]:
                beam_out = beam_out[:,0]
                nbeams_out = 1
            elif mode.lower() in [&#39;e&#39;, &#39;b&#39;, &#39;eb&#39;,]:
                beam_out = beam_out[:,1]
                nbeams_out = 1
            elif not (mode.lower() in [&#39;iqu&#39;,&#39;teb&#39;]):
                raise Exception(&#34;ERROR: Unrecognized mode! Only supported options={t, e, b, eb, i, teb, iqu}. Aborting!&#34;)
        else:
            beam_out = np.ones((lmax+1,))
            nbeams_out = 1

    # print(n_alms, beam_in.shape, beam_out.shape, alm_in.shape)
    if isinstance(pixwin_in, (int,float)):
        pixwin_in = hp.pixwin(int(pixwin_in), lmax=lmax)
        beam_in *= pixwin_in
    
    if isinstance(pixwin_out, (int,float)):
        pixwin_out = hp.pixwin(int(pixwin_out), lmax=lmax)
        beam_out *= pixwin_out

    if (nbeams_in == 1) and (nbeams_out == 1):
        beam_factor = compute_beam_ratio(beam_in, beam_out)
        alm_out = np.zeros_like(alm_in)

        for i in range(n_alms):
            alm_out[i] = hp.almxfl(alm_in[i], beam_factor)

        del alm_in, beam_factor, beam_in, beam_out

        if n_alms == 1: return alm_out[0]

        return alm_out
    
    if n_alms &gt; 1 and nbeams_in*nbeams_out &gt; 1:
        beam_factor = np.zeros((lmax+1, max(nbeams_in, nbeams_out)))
        if nbeams_in == nbeams_out:
            for ibeam in range(nbeams_in):
                beam_factor[:,ibeam] = compute_beam_ratio(beam_in[:,ibeam], beam_out[:,ibeam])
        elif (nbeams_in &gt; nbeams_out) and (nbeams_out == 1):
            for ibeam in range(nbeams_in):
                beam_factor[:,ibeam] = compute_beam_ratio(beam_in[:,ibeam], beam_out)
        
        # print(beam_factor.shape, beam_factor)
        alm_out = np.zeros_like(alm_in)
        for i in range(n_alms):
            alm_out[i] = hp.almxfl(alm_in[i], beam_factor[:,i])

        return alm_out
    
    else:
        raise Exception(&#34;ERROR: Wrong number of beams given. Ensure nbeams_in &gt;= nbeams_out and n_alms &gt;= max(nbeams_in, nbeams_out). Aborting!&#34;)</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.query_dist"><code class="name flex">
<span>def <span class="ident">query_dist</span></span>(<span>nside, vec_center, radius_in_rad, inclusive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_dist(nside, vec_center, radius_in_rad, inclusive=True):
    disc_pix = np.array(hp.query_disc(nside, vec_center, radius_in_rad, inclusive=inclusive))

    vec_center = np.reshape(vec_center, (3,1))
    vec_disc = np.array(hp.pix2vec(nside, disc_pix))
    
    pix_dist = np.arccos(vec_disc.T @ vec_center)[:,0]

    return disc_pix, pix_dist</code></pre>
</details>
</dd>
<dt id="skytools.hpx_utils.roll_bin_Cl"><code class="name flex">
<span>def <span class="ident">roll_bin_Cl</span></span>(<span>Cl_in, dl_min=10, dlbyl=0.4, dl_max=None, fmt_nmt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roll_bin_Cl(Cl_in, dl_min=10, dlbyl=0.4, dl_max=None, fmt_nmt=False):
    Cl_in = np.array(Cl_in)

    if Cl_in.ndim &gt; 2:
        raise Exception(&#34;ERROR: Upto 2-d Cl arrays supported in form [ndim, lmax+1]&#34;)
        
    elif Cl_in.ndim == 2:
        # Assume that Cl_in is [nmaps, lmax+1] in size
        lmax = len(Cl_in[0]) - 1
        nmaps = len(Cl_in)
        Cl_1x2 = np.copy(Cl_in)

        Cl_binned = np.zeros((nmaps, lmax+1))

        for li in range(2, lmax+1) :
            limin = np.maximum((np.floor(np.minimum((1-dlbyl/2)*li, li-(dl_min/2)))), 2)
            limax = np.minimum((np.ceil(np.maximum((1+dlbyl/2)*li, li+(dl_min/2)))), lmax-1)

            if dl_max != None:
                limin = np.maximum(limin, int(np.floor(li - (dl_max/2))))
                limax = np.minimum(limax, int(np.ceil(li + (dl_max/2))))
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)

            Cl_binned[:,li] = (np.sum(np.copy(Cl_1x2)[:,limin:limax], axis=1)) / (limax - limin) #)

        del Cl_1x2

        if fmt_nmt:
            Cl_binned = np.reshape(Cl_binned,(nmaps, 1, lmax+1))
    else:
        lmax = len(Cl_in) - 1

        Cl_1x2 = np.copy(np.array(Cl_in))

        # ells = np.arange(lmax+1)
        # mode_factor = 2.*ells + 1. 
        # Cl_1x2 = mode_factor * Cl_1x2

        Cl_binned = np.zeros((lmax+1,))

        for li in range(2, len(Cl_1x2)) :
            limin = np.maximum(int(np.floor(np.minimum((1-dlbyl/2)*li, li-(dl_min/2)))), 2)
            limax = np.minimum(int(np.ceil(np.maximum((1+dlbyl/2)*li, li+(dl_min/2)))), lmax-1)

            if dl_max != None:
                limin = np.maximum(limin, int(np.floor(li - (dl_max/2))))
                limax = np.minimum(limax, int(np.ceil(li + (dl_max/2))))
            # li = li - 2
            # if li &lt; len(leff):
            #     limin = np.maximum(np.int(np.floor(np.minimum(0.8*li, li-5))), 0)
            #     limax = np.minimum(np.int(np.ceil(np.maximum(1.2*li, li+5))), len(leff)-1)
            Cl_binned[li] = (np.sum(Cl_1x2[limin:limax])) / (limax - limin) #) 

        del Cl_1x2 

        if fmt_nmt:
            Cl_binned = np.reshape(Cl_binned,(1,len(Cl_binned)))

    return Cl_binned</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skytools" href="index.html">skytools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="skytools.hpx_utils.alm_c2fort" href="#skytools.hpx_utils.alm_c2fort">alm_c2fort</a></code></li>
<li><code><a title="skytools.hpx_utils.alm_c_lmaxchanger" href="#skytools.hpx_utils.alm_c_lmaxchanger">alm_c_lmaxchanger</a></code></li>
<li><code><a title="skytools.hpx_utils.alm_fort2c" href="#skytools.hpx_utils.alm_fort2c">alm_fort2c</a></code></li>
<li><code><a title="skytools.hpx_utils.angdist" href="#skytools.hpx_utils.angdist">angdist</a></code></li>
<li><code><a title="skytools.hpx_utils.apodized_gauss_beam" href="#skytools.hpx_utils.apodized_gauss_beam">apodized_gauss_beam</a></code></li>
<li><code><a title="skytools.hpx_utils.calc_binned_Cl" href="#skytools.hpx_utils.calc_binned_Cl">calc_binned_Cl</a></code></li>
<li><code><a title="skytools.hpx_utils.change_resolution" href="#skytools.hpx_utils.change_resolution">change_resolution</a></code></li>
<li><code><a title="skytools.hpx_utils.compute_beam_ratio" href="#skytools.hpx_utils.compute_beam_ratio">compute_beam_ratio</a></code></li>
<li><code><a title="skytools.hpx_utils.iqu2teb" href="#skytools.hpx_utils.iqu2teb">iqu2teb</a></code></li>
<li><code><a title="skytools.hpx_utils.mask_udgrade" href="#skytools.hpx_utils.mask_udgrade">mask_udgrade</a></code></li>
<li><code><a title="skytools.hpx_utils.process_alm" href="#skytools.hpx_utils.process_alm">process_alm</a></code></li>
<li><code><a title="skytools.hpx_utils.query_dist" href="#skytools.hpx_utils.query_dist">query_dist</a></code></li>
<li><code><a title="skytools.hpx_utils.roll_bin_Cl" href="#skytools.hpx_utils.roll_bin_Cl">roll_bin_Cl</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>